import { Scenes } from 'telegraf';
import {
    feedingDetailsScene,
    setGlobalDatabaseForFeedingDetails,
} from '../../src/scenes/feeding-details';
import { DatabaseService } from '../../src/services/database';
import { Telegraf } from 'telegraf';
import { BotContext } from '../../src/types';

// Mock –¥–ª—è DatabaseService
const mockDatabase = {
    getUserByTelegramId: jest.fn(),
    createUser: jest.fn(),
    getSetting: jest.fn(),
    createFeeding: jest.fn(),
    getAllUsers: jest.fn(),
    getLastFeeding: jest.fn(),
    getStats: jest.fn(),
    updateFeedingDetails: jest.fn(),
} as unknown as DatabaseService;

// Mock –¥–ª—è Telegraf
const mockBot = {
    telegram: {
        sendMessage: jest.fn(),
    },
} as unknown as Telegraf<BotContext>;

describe('feedingDetailsScene', () => {
    let ctx: any;

    beforeEach(() => {
        // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –≥–ª–æ–±–∞–ª—å–Ω–æ–π –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –¥–ª—è feedingDetailsScene
        setGlobalDatabaseForFeedingDetails(mockDatabase);

        ctx = {
            from: {
                id: 123456789,
                username: 'testuser',
                first_name: 'Test',
            },
            session: {},
            reply: jest.fn(),
            scene: {
                enter: jest.fn(),
                reenter: jest.fn(),
            },
            telegram: mockBot.telegram,
        };
    });

    afterEach(() => {
        jest.clearAllMocks();
    });

    describe('enter', () => {
        it('should show error message when no lastFeedingId in session', async () => {
            ctx.session.lastFeedingId = null;

            await (feedingDetailsScene as any).enterMiddleware()[0](ctx);

            expect(ctx.reply).toHaveBeenCalledWith(
                '‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω–æ –∫–æ—Ä–º–ª–µ–Ω–∏–µ –¥–ª—è —É—Ç–æ—á–Ω–µ–Ω–∏—è –¥–µ—Ç–∞–ª–µ–π.',
                expect.any(Object)
            );
        });

        it('should show details input message when lastFeedingId exists', async () => {
            ctx.session.lastFeedingId = 1;

            await (feedingDetailsScene as any).enterMiddleware()[0](ctx);

            expect(ctx.reply).toHaveBeenCalledWith(
                expect.stringContaining('üìù –£—Ç–æ—á–Ω–µ–Ω–∏–µ –¥–µ—Ç–∞–ª–µ–π –∫–æ—Ä–º–ª–µ–Ω–∏—è'),
                expect.any(Object)
            );
        });
    });

    describe('on text', () => {
        it('should enter main scene when "üè† –ù–∞ –≥–ª–∞–≤–Ω—É—é" is received', async () => {
            ctx.message = { text: 'üè† –ù–∞ –≥–ª–∞–≤–Ω—É—é' };
            ctx.session.lastFeedingId = 1;

            await (feedingDetailsScene as any).onMiddleware('text')[0](ctx);

            expect(ctx.scene.enter).toHaveBeenCalledWith('MAIN');
        });

        it('should show error when no lastFeedingId in session', async () => {
            ctx.message = { text: 'Some details' };
            ctx.session.lastFeedingId = null;

            await (feedingDetailsScene as any).onMiddleware('text')[0](ctx);

            expect(ctx.reply).toHaveBeenCalledWith(
                '‚ùå –û—à–∏–±–∫–∞: –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –∫–æ—Ä–º–ª–µ–Ω–∏–µ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è'
            );
        });

        it('should show error when database is not initialized', async () => {
            ctx.message = { text: 'Some details' };
            ctx.session.lastFeedingId = 1;

            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –≥–ª–æ–±–∞–ª—å–Ω—É—é –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
            setGlobalDatabaseForFeedingDetails(null as any);

            await (feedingDetailsScene as any).onMiddleware('text')[0](ctx);

            expect(ctx.reply).toHaveBeenCalledWith(
                '‚ùå –û—à–∏–±–∫–∞: –±–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞'
            );
        });

        it('should show error when details parsing fails', async () => {
            ctx.message = { text: 'Invalid details' };
            ctx.session.lastFeedingId = 1;

            // –ú–æ–∫–∞–µ–º FeedingParser –¥–ª—è –≤–æ–∑–≤—Ä–∞—Ç–∞ –æ—à–∏–±–∫–∏
            jest.mock('../../src/services/feeding-parser', () => {
                return {
                    FeedingParser: {
                        parseDetails: jest.fn().mockReturnValue({
                            isValid: false,
                            error: '–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç',
                        }),
                        getExamples: jest
                            .fn()
                            .mockReturnValue(['–ü—Ä–∏–º–µ—Ä 1', '–ü—Ä–∏–º–µ—Ä 2']),
                    },
                };
            });

            await (feedingDetailsScene as any).onMiddleware('text')[0](ctx);

            expect(ctx.reply).toHaveBeenCalledWith(
                expect.stringContaining('‚ùå –û—à–∏–±–∫–∞: –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç'),
                expect.any(Object)
            );
        });

        it('should update feeding details and notify users', async () => {
            ctx.message = { text: '–°—É—Ö–æ–π –∫–æ—Ä–º 150–≥' };
            ctx.session.lastFeedingId = 1;

            // –ú–æ–∫–∞–µ–º FeedingParser –¥–ª—è —É—Å–ø–µ—à–Ω–æ–≥–æ –ø–∞—Ä—Å–∏–Ω–≥–∞
            jest.mock('../../src/services/feeding-parser', () => {
                return {
                    FeedingParser: {
                        parseDetails: jest.fn().mockReturnValue({
                            isValid: true,
                            amount: 150,
                            foodType: 'dry',
                            details: '–°—É—Ö–æ–π –∫–æ—Ä–º 150–≥',
                        }),
                        getExamples: jest
                            .fn()
                            .mockReturnValue(['–ü—Ä–∏–º–µ—Ä 1', '–ü—Ä–∏–º–µ—Ä 2']),
                    },
                };
            });

            mockDatabase.getUserByTelegramId = jest.fn().mockResolvedValueOnce({
                id: 1,
                telegramId: 123456789,
                username: 'testuser',
                notificationsEnabled: true,
                feedingInterval: 210,
                createdAt: new Date(),
            });

            mockDatabase.updateFeedingDetails = jest
                .fn()
                .mockResolvedValueOnce(undefined);

            mockDatabase.getAllUsers = jest.fn().mockResolvedValueOnce([
                {
                    id: 1,
                    telegramId: 123456789,
                    username: 'testuser',
                    notificationsEnabled: true,
                    feedingInterval: 210,
                    createdAt: new Date(),
                },
            ]);

            await (feedingDetailsScene as any).onMiddleware('text')[0](ctx);

            expect(mockDatabase.updateFeedingDetails).toHaveBeenCalledWith(
                1,
                150,
                'dry',
                '–°—É—Ö–æ–π –∫–æ—Ä–º 150–≥'
            );
            expect(ctx.telegram.sendMessage).toHaveBeenCalledWith(
                123456789,
                expect.stringContaining('‚úÖ –î–µ—Ç–∞–ª–∏ –∫–æ—Ä–º–ª–µ–Ω–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω—ã!')
            );
            expect(ctx.reply).toHaveBeenCalledWith(
                expect.stringContaining('‚úÖ –î–µ—Ç–∞–ª–∏ –∫–æ—Ä–º–ª–µ–Ω–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω—ã!'),
                expect.any(Object)
            );
        });
    });
});
